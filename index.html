<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Jolt Physics: Architecture of Jolt Physics</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="LogoSmall.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Jolt Physics
   </div>
   <div id="projectbrief">A multi core friendly Game Physics Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Architecture of Jolt Physics </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_Docs_Architecture"></a> For demos and videos go to the <a class="el" href="md__docs__samples.html">Samples</a> section.</p>
<h1>Bodies</h1>
<p>We use a pretty traditional physics engine setup. We have rigid bodies (<a class="el" href="class_j_p_h_1_1_body.html">Body</a>) that have attached collision volumes (<a class="el" href="class_j_p_h_1_1_shape.html">Shape</a>). Bodies can either be static (not simulating), dynamic (moved by forces) or kinematic (moved by velocities only). Each moving body has a <a class="el" href="class_j_p_h_1_1_motion_properties.html">MotionProperties</a> object that contains information about the movement of the object. Static bodies do not have this to save space (but they can be configured to have it if a static body needs to become dynamic during its lifetime by setting <a class="el" href="class_j_p_h_1_1_body_creation_settings.html#a6a548a9eb68ccddddbea96a788bf0169">BodyCreationSettings::mAllowDynamicOrKinematic</a>).</p>
<p>Bodies are inserted into the <a class="el" href="class_j_p_h_1_1_physics_system.html">PhysicsSystem</a> through the <a class="el" href="class_j_p_h_1_1_body_interface.html">BodyInterface</a>. The body interface comes in two flavors: A locking and a non-locking variant. The locking variant uses a mutex array (a fixed size array of mutexes, bodies are associated with a mutex through hashing and multiple bodies use the same mutex, see <a class="el" href="class_j_p_h_1_1_mutex_array.html">MutexArray</a>) to prevent concurrent access to the same body. The non-locking variant doesn't use mutexes, so requires the user to be careful.</p>
<p>In general, body ID's (<a class="el" href="class_j_p_h_1_1_body_i_d.html">BodyID</a>) are used to refer to bodies. You can access a body through the following construct: </p><pre class="fragment">JPH::BodyLockInterface lock_interface = physics_system.GetBodyLockInterface(); // Or GetBodyLockInterfaceNoLock
JPH::BodyID body_id = ...; // Obtain ID to body

// Scoped lock
{
    JPH::BodyLockRead lock(lock_interface, body_id);
    if (lock.Succeeded()) // body_id may no longer be valid
    {
        const JPH::Body &amp;body = lock.GetBody();

        // Do something with body
        ...
    }
}
</pre><p> When another thread has removed the body between the time the body ID was obtained and the lock, the lock will fail. While the lock is taken, other threads cannot modify the body, so it is safe to work with it. Each body ID contains a sequence number, so body ID's will only be reused after many add/remove cycles.</p>
<h1>Shapes</h1>
<p>Each body has a shape attached that determines the collision volume. The following shapes are available (in order of computational complexity):</p>
<ul>
<li><a class="el" href="class_j_p_h_1_1_sphere_shape.html">SphereShape</a> - A sphere centered around zero.</li>
<li><a class="el" href="class_j_p_h_1_1_box_shape.html">BoxShape</a> - A box centered around zero.</li>
<li><a class="el" href="class_j_p_h_1_1_capsule_shape.html">CapsuleShape</a> - A capsule centered around zero.</li>
<li><a class="el" href="class_j_p_h_1_1_tapered_capsule_shape.html">TaperedCapsuleShape</a> - A capsule with different radii at the bottom and top.</li>
<li><a class="el" href="class_j_p_h_1_1_cylinder_shape.html">CylinderShape</a> - A cylinder shape. Note that cylinders are the least stable of all shapes, so use another shape if possible.</li>
<li><a class="el" href="class_j_p_h_1_1_convex_hull_shape.html">ConvexHullShape</a> - A convex hull defined by a set of points.</li>
<li><a class="el" href="class_j_p_h_1_1_static_compound_shape.html">StaticCompoundShape</a> - A shape containing other shapes. This shape is constructed once and cannot be changed afterwards. Child shapes are organized in a tree to speed up collision detection.</li>
<li><a class="el" href="class_j_p_h_1_1_mutable_compound_shape.html">MutableCompoundShape</a> - A shape containing other shapes. This shape can be constructed/changed at runtime and trades construction time for runtime performance. Child shapes are organized in a list to make modification easy.</li>
<li><a class="el" href="class_j_p_h_1_1_mesh_shape.html">MeshShape</a> - A shape consisting of triangles. Any body that uses this shape needs to be static.</li>
<li><a class="el" href="class_j_p_h_1_1_height_field_shape.html">HeightFieldShape</a> - A shape consisting of NxN points that define the height at each point, very suitable for representing hilly terrain. Any body that uses this shape needs to be static.</li>
</ul>
<p>Next to this there are a number of decorator shapes that change the behavior of their children:</p>
<ul>
<li><a class="el" href="class_j_p_h_1_1_scaled_shape.html">ScaledShape</a> - This shape can uniformly scale a child shape. Note that if a shape is rotated first and then scaled, you can introduce shearing which is not supported by the library.</li>
<li><a class="el" href="class_j_p_h_1_1_rotated_translated_shape.html">RotatedTranslatedShape</a> - This shape can rotate and translate a child shape, it can e.g. be used to offset a sphere from the origin.</li>
<li><a class="el" href="class_j_p_h_1_1_offset_center_of_mass_shape.html">OffsetCenterOfMassShape</a> - This shape does not change its child shape but it does shift the calculated center of mass for that shape. It allows you to e.g. shift the center of mass of a vehicle down to improve its handling.</li>
</ul>
<h2>Convex Radius</h2>
<p>In order to speed up the collision detection system, all convex shapes use a convex radius. The provided shape will first be shrunken by the convex radius and then inflated again by the same amount, resulting in a rounded off shape:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft"><img src="ConvexRadius.jpg" alt="" class="inline" title="Convex Radius"/>   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><em>In this example a box (green) was created with a fairly large convex radius. The shape is shrunken first (dashed green line) and then inflated again equally on all sides. The resulting shape as seen by the collision detection system is shown in blue. A larger convex radius results in better performance but a less accurate simulation. A convex radius of 0 is allowed.</em>   </td></tr>
</table>
<h2>Center of Mass</h2>
<p><b>Beware: When a shape is created, it will automatically recenter itself around its center of mass.</b> The center of mass can be obtained by calling <a class="el" href="class_j_p_h_1_1_shape.html#abdd580a03bcdfb07eec924c495c193de">Shape::GetCenterOfMass</a> and most functions operate in this Center of Mass (COM) space. Some functions work in the original space the shape was created in, they usually have World Space (WS) or Shape Space (SS) in their name (or documentation).</p>
<p><img src="ShapeCenterOfMass.jpg" alt="" class="inline" title="Shape Center of Mass"/></p>
<p>As an example, say we create a box and then translate it: </p><pre class="fragment">// Create box of 2x2x2 m (you specify half the side)
JPH::BoxShapeSettings box(JPH::Vec3(1, 1, 1));
JPH::Ref&lt;Shape&gt; box_shape = box.Create().Get();

// Offset it by 10 m
JPH::RotatedTranslatedShapeSettings translated_box(JPH::Vec3(10, 0, 0), JPH::Quat::sIdentity(), box_shape);
JPH::Ref&lt;Shape&gt; translated_box_shape = translated_box.Create().Get();

// Cast a ray against the offset box (WRONG!)
JPH::RayCast ray;
ray.mOrigin = JPH::Vec3(10, 2, 0);
ray.mDirection = JPH::Vec3(0, -2, 0);

// Cast ray
JPH::RayCastResult hit;
bool had_hit = translated_box_shape-&gt;CastRay(ray, JPH::SubShapeIDCreator(), hit);
JPH_ASSERT(!had_hit); // There's no hit because we did not correct for COM!

// Convert the ray to center of mass space for the shape (CORRECT!)
ray.mOrigin -= translated_box_shape-&gt;GetCenterOfMass();

// Cast ray
had_hit = translated_box_shape-&gt;CastRay(ray, JPH::SubShapeIDCreator(), hit);
JPH_ASSERT(had_hit); // Ray was in COM space, now there's a hit!
</pre><p> In the same way calling: </p><pre class="fragment">translated_box_shape-&gt;GetLocalBounds();
</pre><p> will return a box of size 2x2x2 centered around the origin, so in order to get it back to the space in which it was originally created you need to offset the bounding box: </p><pre class="fragment">JPH::AABox shape_bounds = translated_box_shape-&gt;GetLocalBounds();
shape_bounds.Translate(translated_box_shape-&gt;GetCenterOfMass());
JPH_ASSERT(shape_bounds == JPH::AABox(JPH::Vec3(9, -1, -1), JPH::Vec3(11, 1, 1))); // Now we have the box relative to how we created it
</pre><p> Note that when you work with interface of <a class="el" href="class_j_p_h_1_1_broad_phase_query.html">BroadPhaseQuery</a>, <a class="el" href="class_j_p_h_1_1_narrow_phase_query.html">NarrowPhaseQuery</a> or <a class="el" href="class_j_p_h_1_1_transformed_shape.html">TransformedShape</a> this transformation is done for you.</p>
<h1>Constraints</h1>
<p>Bodies can be connected to each other using constraints (<a class="el" href="class_j_p_h_1_1_constraint.html">Constraint</a>).</p>
<p>The following constraints are available:</p>
<ul>
<li><a class="el" href="class_j_p_h_1_1_fixed_constraint_settings.html">FixedConstraint</a> - Will attach a body to another without any degrees of freedom.</li>
<li><a class="el" href="class_j_p_h_1_1_distance_constraint_settings.html">DistanceConstraint</a> - Will attach two bodies with a stick (removing 1 degree of freedom).</li>
<li><a class="el" href="class_j_p_h_1_1_point_constraint_settings.html">PointConstraint</a> - Will attach two bodies in a single point (removing 3 degrees of freedom)</li>
<li><a class="el" href="class_j_p_h_1_1_hinge_constraint_settings.html">HingeConstraint</a> - Will attach two bodies through a hinge.</li>
<li><a class="el" href="class_j_p_h_1_1_cone_constraint_settings.html">ConeConstraint</a> - Attaches two bodies in a point and will limit the rotation within a cone.</li>
<li><a class="el" href="class_j_p_h_1_1_slider_constraint_settings.html">SliderConstraint</a> - Attaches two bodies and allows only movement in a single translation axis (also known as prismatic constraint).</li>
<li><a class="el" href="class_j_p_h_1_1_swing_twist_constraint_settings.html">SwingTwistConstraint</a> - Attaches two bodies using a point constraint and a swing-twist constraint which approximates the shoulder joint of a human.</li>
<li><a class="el" href="class_j_p_h_1_1_six_d_o_f_constraint_settings.html">SixDOFConstraint</a> - The most configurable joint allows specifying per translation axis and rotation axis what the limits are.</li>
<li><a class="el" href="class_j_p_h_1_1_path_constraint_settings.html">PathConstraint</a> - This constraint allows attaching two bodies connected through a Hermite spline path.</li>
<li><a class="el" href="class_j_p_h_1_1_vehicle_constraint_settings.html">VehicleConstraint</a> - This constraint adds virtual wheels or tracks to a body and allows it to behave as a vehicle.</li>
</ul>
<p>Most of the constraints support motors (<a class="el" href="class_j_p_h_1_1_motor_settings.html">MotorSettings</a>) and allow the relative position/orientation of the bodies to be driven to a particular velocity or position.</p>
<p>If you want to constrain a dynamic object to the unmovable 'world' you can use <a class="el" href="class_j_p_h_1_1_body.html#a0edff00621af191a250dc1a0d29433db">Body::sFixedToWorld</a> instead of creating a static body.</p>
<p>Adding and removing constraints can be done from multiple threads, but the constraints themselves do not have any protection against concurrent access. We assume that constraints are owned by some object (e.g. a Ragdoll) and that object ensures that it only modifies its own constraints and contains its own synchronization logic. Constraints can be freely modified except during the physics simulation step.</p>
<p>Contact constraints (when bodies collide) are not handled through the (<a class="el" href="class_j_p_h_1_1_constraint.html">Constraint</a>) class but through the <a class="el" href="class_j_p_h_1_1_contact_constraint_manager.html">ContactConstraintManager</a> which is considered an internal class.</p>
<h1>Broad Phase</h1>
<p>When bodies are added to the PhysicsSystem, they are inserted in the broad phase (<a class="el" href="class_j_p_h_1_1_broad_phase_quad_tree.html">BroadPhaseQuadTree</a>). This provides quick coarse collision detection based on the axis aligned bounding box (AABB) of a body.</p>
<p>The broad phase is divided in layers, each layer has a AABB quad tree associated with it. When constructing the physics system a <a class="el" href="namespace_j_p_h.html#a7029cd45bb369c6cc6b978e11facdaec">ObjectLayerPairFilter</a> needs to be provided which determines which object layers collide with which other layer. If two layers don't collide, the objects inside those layers cannot collide. A standard setup would be to have a MOVING and a NON_MOVING layer, where NON_MOVING doesn't collide with NON_MOVING and all other permutations collide. This ensures that all static bodies are in one tree (which is infrequently updated) and all dynamic bodies are in another (which is updated every simulation step). It is possible to create more layers like a BULLET layer for high detail collision bodies that are attached to lower detail simulation bodies, the MOVING layer would not collide with the BULLET layer, but when performing e.g. weapon collision queries you can filter for only objects in the BULLET layer.</p>
<p>Since we want to access bodies concurrently the broad phase has special behavior. When a body moves, all nodes in the AABB tree from root to the node where the body resides will be expanded using a lock-free approach. This way multiple threads can move bodies at the same time without requiring a lock on the broad phase. Nodes that have been expanded are marked and during the next physics step a new tight-fitting tree will be built in the background while the physics step is running. This new tree will replace the old tree before the end of the simulation step. This is possible since no bodies can be added/removed during the physics step.</p>
<p>When doing a query against the broad phase (<a class="el" href="class_j_p_h_1_1_broad_phase_query.html">BroadPhaseQuery</a>), you generally will get a body ID for intersecting objects. If a collision query takes a long time to process the resulting bodies (e.g. across multiple simulation steps), you can safely keep using the body ID's as specified in the <a href="#Bodies">Bodies</a> section.</p>
<h1>Narrow Phase</h1>
<p>A narrow phase query (<a class="el" href="class_j_p_h_1_1_narrow_phase_query.html">NarrowPhaseQuery</a>) will first query the broad phase for intersecting bodies and will under the protection of a body lock construct a transformed shape (<a class="el" href="class_j_p_h_1_1_transformed_shape.html">TransformedShape</a>) object. This object contains the transform, a reference counted shape and a body ID. Since the shape will not be deleted until you destroy the TransformedShape object, it is a consistent snapshot of the collision information of the body. This ensures that the body is only locked for a short time frame and makes it possible to do the bulk of the collision detection work outside the protection of a lock.</p>
<p>For very long running jobs (e.g. navigation mesh creation) it is possible to query all transformed shapes in an area and then do the processing work using a long running thread without requiring additional locks (see <a class="el" href="class_j_p_h_1_1_narrow_phase_query.html#a05eeec77c050aee93536c08a5c45750b">NarrowPhaseQuery::CollectTransformedShapes</a>).</p>
<p>The narrow phase queries are all handled through the <a class="el" href="class_j_p_h_1_1_g_j_k_closest_point.html">GJK</a> and <a class="el" href="class_j_p_h_1_1_e_p_a_penetration_depth.html">EPA</a> algorithms.</p>
<h1>The Simulation Step</h1>
<p>The simulation step <a class="el" href="class_j_p_h_1_1_physics_system.html#a3ac306aa3c34bdbc3b60f6b427c4bd75">PhysicsSystem::Update</a> uses jobs (<a class="el" href="class_j_p_h_1_1_job_system.html">JobSystem</a>) to perform the needed work. This allows spreading the workload across multiple CPU's. We use a Sequential Impulse solver with warm starting as described in <a href="https://box2d.org/files/ErinCatto_ModelingAndSolvingConstraints_GDC2009.pdf">Modeling and Solving Constraints - Erin Catto</a></p>
<p>Each physics step can be divided into multiple sub steps. There are collision and integration steps. For each collision step we run X integration steps, so if you run the simulation at 60 Hz with 2 collision steps and 3 integration steps we run:</p>
<ul>
<li>Collision<ul>
<li>Integration (1/360s)</li>
<li>Integration (1/360s)</li>
<li>Integration (1/360s)</li>
</ul>
</li>
<li>Collision<ul>
<li>Integration (1/360s)</li>
<li>Integration (1/360s)</li>
<li>Integration (1/360s)</li>
</ul>
</li>
</ul>
<p>In general, the system is stable when running at 60 Hz with 1 collision and 1 integration step.</p>
<h1>Conventions and limits</h1>
<p>Jolt Physics uses a right handed coordinate system with Y-up. It is easy to use another axis as up axis by changing the gravity vector using <a class="el" href="class_j_p_h_1_1_physics_system.html#a3b98ac96177272d378474f3725fb9116">PhysicsSystem::SetGravity</a>. Some shapes like the <a class="el" href="class_j_p_h_1_1_height_field_shape_settings.html">HeightFieldShape</a> will need an additional <a class="el" href="class_j_p_h_1_1_rotated_translated_shape_settings.html">RotatedTranslatedShape</a> to rotate it to the new up axis and vehicles (<a class="el" href="class_j_p_h_1_1_vehicle_constraint_settings.html">VehicleConstraint</a>) will need their new up-axis specified too.</p>
<p>We use column-major vectors and matrices, this means that to transform a point you need to multiply it on the right hand side: TransformedPoint = Matrix * Point.</p>
<p>Note that the physics simulation works best if you use SI units (meters, radians, seconds, kg). In order for the simluation to be accurate, dynamic objects should be in the order [0.1, 10] meters long and have speeds in the order of [0, 500] m/s. Static object should be in the order [0.1, 2000] meter long. If you are using different units, consider scaling the objects before passing them on to the physics simulation. Also try to ensure that all simulation takes place within 2 km from the origin to avoid floating point accuracy problems.</p>
<h1>Continuous Collision Detection</h1>
<p>Each body has a motion quality setting (<a class="el" href="namespace_j_p_h.html#afdb153e24c50b48cbc3d65c789dbc5b2">EMotionQuality</a>). By default the motion quality is <a class="el" href="namespace_j_p_h.html#afdb153e24c50b48cbc3d65c789dbc5b2a4984667940802dedc139aa7a430a6553">Discrete</a>. This means that at the beginning of each simulation step we will perform collision detection and if no collision is found, the body is free to move according to its velocity. This usually works fine for big or slow moving objects. Fast and small objects can easily 'tunnel' through thin objects because they can completely move through them in a single time step. For these objects there is the motion quality <a class="el" href="namespace_j_p_h.html#afdb153e24c50b48cbc3d65c789dbc5b2a38f63d197afcc4a4965d98f9401c36e0">LinearCast</a>. Objects that have this motion quality setting will do the same collision detection at the beginning of the simulation step, but once their new position is known, they will do an additional CastShape to check for any collisions that may have been missed. If this is the case, the object is placed back to where the collision occurred and will remain there until the next time step. This is called 'time stealing' and has the disadvantage that an object may appear to move much slower for a single time step and then speed up again. The alternative, back stepping the entire simulation, is computationally heavy so was not implemented.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft"><img src="MotionQuality.jpg" alt="" class="inline" title="Motion Quality"/>   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><em>With the Discrete motion quality the blue object tunnels through the green object in a single time step. With motion quality LinearCast it doesn't.</em>   </td></tr>
</table>
<p>Fast rotating long objects are also to be avoided, as the LinearCast motion quality will fully rotate the object at the beginning of the time step and from that orientation perform the CastShape, there is a chance that the object misses a collision because it rotated through it.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft"><img src="LongAndThin.jpg" alt="" class="inline" title="Long and Thin"/>   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><em>Even with the LinearCast motion quality the blue object rotates through the green object in a single time step.</em>   </td></tr>
</table>
<h1>Cooking Data and Saving</h1>
<p>Data needs to be converted into an optimized format in order to be usable in the physics simulation. The uncooked data is usually stored in a <a class="el" href="class_j_p_h_1_1_shape_settings.html">Settings</a> object and then converted to cooked format by a <a class="el" href="class_j_p_h_1_1_shape_settings.html#a20ba501ad9c40b8ffadb0d883bde430d">Create</a> function that returns a <a class="el" href="class_j_p_h_1_1_result.html">Result</a> object that indicates success or failure and provides the cooked object. There are two ways of serializing data:</p>
<ul>
<li>The uncooked data can be serialized using the <a class="el" href="class_j_p_h_1_1_object_stream.html">ObjectStream</a> system (either in <a class="el" href="class_j_p_h_1_1_object_stream_binary_out.html">binary</a> or in <a class="el" href="class_j_p_h_1_1_object_stream_text_out.html">text</a> format), data stored in this way is likely to be compatible with future versions of the library (although there is no 100% guarantee of this).</li>
<li>The cooked data can be serialized using the <a class="el" href="class_j_p_h_1_1_shape.html#ae9bd5187bbdaf81a538eb2dd92eb8baa">SaveBinaryState</a> interface that various objects provide. Data stored in this way is optimized for simulation performance and loading speed but is very likely to change between versions of the library, so this should never be your primary data format.</li>
</ul>
<p>As the library does not offer an exporter from content creation packages and since most games will have their own content pipeline, we encourage you to store data in your own format, cook data while cooking the game data and store the result using the SaveBinaryState interface (and provide a way to force a re-cook when the library is updated).</p>
<h1>Deterministic Simulation</h1>
<p>The physics simulation is deterministic provided that:</p>
<ul>
<li>The APIs that modify the simulation are called in exactly the same order. For example, bodies and constraints need to be added/removed/modified in exactly the same order so that the state at the beginning of a simulation step is exactly the same for both simulations.</li>
<li>The simulation uses the exact same version of the library.</li>
<li>The simulation runs on the same CPU model and is compiled to the same binary code.</li>
</ul>
<p>If you're willing to sacrifice some performance, the last point can be mitigated. The library doesn't use any SIMD intrinsics that return an approximate result (e.g. 1/sqrt(x) or 1/x) which will differ between e.g. Intel and AMD. Furthermore, by default we compile with 'fast math' and 'fused multiply add' enabled, these will also result in differences across CPUs. You'll need to compile with 'strict math' enabled (-ffp-model=strict in clang) and disable 'fused multiply add' (see JPH_USE_FMADD). Deterministic simulation across platforms is even less likely to happen, you may need to turn off optimization altogether. There is a unit test that checks determinism, but it does not test for determinism across CPU models / platforms so no guarantees are made here.</p>
<p>When running the Samples Application you can press ESC, Physics Settings and check the 'Check Determinism' checkbox. Before every simulation step we will record the state using the <a class="el" href="class_j_p_h_1_1_state_recorder.html">StateRecorder</a> interface, rewind the simulation and do the step again to validate that the simulation runs deterministically. Some of the tests (e.g. the MultiThreaded) test will explicitly disable the check because they randomly add/remove bodies from different threads. This violates the first rule so will not result in a deterministic simulation.</p>
<h1>The Simulation Step in Detail</h1>
<p>The job graph looks like this:</p>
<p><img src="PhysicsSystemUpdate.svg" alt="" style="pointer-events: none;" class="inline" title="Job Graph Physics Step"/></p>
<p>Note that each job indicates if it reads/writes positions/velocities and if it deactivates/activates bodies. We do not allow jobs to read/write the same data concurrently. The arrows indicate the order in which jobs are executed. Yellow blocks mean that there are multiple jobs of this type. Dotted arrows have special meaning and are explained below.</p>
<h2>Broad Phase Update Prepare</h2>
<p>This job will refit the AABBs of the broad phase. It does this by building a new tree while keeping the old one available as described in the <a href="#Broad Phase">Broad Phase</a> section.</p>
<h2>Broad Phase Update Finalize</h2>
<p>This job will simply swap the new tree with the old tree. The old tree will be discarded at the beginning of the next PhysicsSystem::Update call so that any broad phase query can continue to run.</p>
<h2>Step Listeners</h2>
<p>You can register one or more step listeners (See <a class="el" href="class_j_p_h_1_1_physics_system.html#a0ac2a3b50d18c25ff1b21c81f5b619cd">PhysicsSystem::AddStepListener</a>). This job will call <a class="el" href="class_j_p_h_1_1_physics_step_listener.html#a72b6bd08c6d54de29327f4fe7d779f0d">PhysicsStepListener::OnStep</a> for every listener. This can be used to do work that needs to be done at the beginning of each step, e.g. set velocities on ragdoll bodies.</p>
<h2>Apply Gravity</h2>
<p>A number of these jobs run in parallel. Each job takes a batch of active bodies and applies gravity and damping (updating linear and angular velocity).</p>
<h2>Determine Active Constraints</h2>
<p>This job will go through all non-contact constraints and determine which constraints are active based on if the bodies that the constraint connects to are active.</p>
<h2>Build Islands from Constraints</h2>
<p>This job will go through all non-contact constraints and assign the involved bodies and constraint to the same island. Since we allow concurrent insertion/removal of bodies we do not want to keep island data across multiple simulation steps, so we recreate the islands from scratch every simulation step. The operation is lock-free and O(N) where N is the number of constraints.</p>
<p>If a constraint connects an active and a non-active body, the non-active body is woken up.</p>
<h2>Find Collisions</h2>
<p>This job will do broad and narrow phase checks. Initially a number of jobs are started based on the amount of active bodies. The job will do the following:</p>
<ul>
<li>Take a batch of active bodies and collide them against the broadphase.</li>
<li>When a collision pair is found it is inserted in a lock free queue to be processed later.</li>
<li>If the queue is full, it will be processed immediately (more Find Collisions jobs are spawned if not all CPU cores are occupied yet as the queue starts to fill up).</li>
<li>If there are no more active bodies to process, the job will start to perform narrow phase collision detection and set up contact constraints if any collisions are found.</li>
<li>As soon as a narrow phase pair is processed it will recheck if there are new active bodies to be processed (active bodies can be generated by an active body colliding with an inactive body) and if so process them.</li>
<li>When there are no more active bodies to test and no more collision pairs to be processed the job terminates.</li>
</ul>
<p>Note that this job cannot start until apply gravity is done because the velocity needs to be known for elastic collisions to be calculated properly.</p>
<p>The contact points between the two bodies will be determined by the <a class="el" href="class_j_p_h_1_1_g_j_k_closest_point.html">GJK</a> and <a class="el" href="class_j_p_h_1_1_e_p_a_penetration_depth.html">EPA</a> algorithms. For each contact point we will calculate the face that belongs to that contact point. The faces of both bodies are clipped against each other (<a class="el" href="namespace_j_p_h.html#ab658274b19d2eb847ed725c3424ed67d">ManifoldBetweenTwoFaces</a>) so that we have a polygon (or point / line) that represents the contact between the two bodies (contact manifold).</p>
<p>Multiple contact manifolds with similar normals are merged together (PhysicsSystem::ProcessBodyPair::ReductionCollideShapeCollector). After this the contact constraints are created in the <a class="el" href="class_j_p_h_1_1_contact_constraint_manager.html">ContactConstraintManager</a> and their Jacobians / effective masses calculated.</p>
<p>Contacting bodies are also linked together to form islands. This is the same operation as described in the <a href="#Build Islands From Constraints">Build Islands From Constraints</a> section.</p>
<p>The narrow phase makes use of a lock free contact cache. We have 2 caches, one that is used for reading (which contains the contacts from the previous step) and one for writing new contact pairs. When a contact point is preserved from the last simulation step, it will be copied from the read cache to the write cache.</p>
<h2>Setup Velocity Constraints</h2>
<p>This job will go through all non-contact constraints and prepare them for execution. This involves calculating Jacobians and effective masses for each constraint part.</p>
<h2>Finalize Islands</h2>
<p>This job will finalize the building of the simulation islands. Each island contains bodies that interact with each other through a contact point or through a constraint. These islands will be simulated separately in different jobs later. The finalization of the islands is an O(N) operation where N is the amount of active bodies (see <a class="el" href="class_j_p_h_1_1_island_builder.html#acbcf8e0511c577b0db0bdd87454f7044">IslandBuilder::Finalize</a>).</p>
<h2>Set Body Island Idx</h2>
<p>This job does some housekeeping work that can be executed concurrent to the solver:</p>
<ul>
<li>It will assign the island ID to all bodies (which is mainly used for debugging purposes)</li>
</ul>
<h2>Solve Velocity Constraints</h2>
<p>A number of these jobs will run in parallel. Each job takes the next unprocessed island and will run the iterative constraint solver for that island. It will first apply the impulses applied from the previous simulation step (which are stored in the contact cache) to warm start the solver. It will then repeatedly iterate over all contact and non-contact constraints until either the applied impulses are too small or a max iteration count is reached (<a class="el" href="struct_j_p_h_1_1_physics_settings.html#ad782d17be6e4102465fa23cbf2336281">PhysicsSettings::mNumVelocitySteps</a>). The result will be that the new velocities are known for all active bodies. In the last integration step, the applied impulses are stored in the contact cache for the next step.</p>
<h2>Pre Integrate</h2>
<p>This job prepares the CCD buffers.</p>
<h2>Integrate &amp; Clamp Velocities</h2>
<p>This job will integrate the velocity and update the position. It will clamp the velocity to the max velocity.</p>
<p>Depending on the motion quality (<a class="el" href="namespace_j_p_h.html#afdb153e24c50b48cbc3d65c789dbc5b2">EMotionQuality</a>) of the body, it will schedule a body for continuous collision detection (CCD) if its movement is bigger than some treshold based on the <a class="el" href="class_j_p_h_1_1_shape.html#aaf0e6b5a433304648358edebe4cc593c">inner radius</a>) of the shape.</p>
<h2>Post Integrate</h2>
<p>Find CCD Contact jobs are created on the fly depending on how many CCD bodies were found. If there are no CCD bodies it will immediately start Resolve CCD Contacts.</p>
<h2>Find CCD Contacts</h2>
<p>A number of jobs wil run in parallel and pick up bodies that have been scheduled for CCD and will do a linear cast to detect the first collision. It always allows movement of the object by a fraction if its inner radius in order to prevent it from getting fully stuck.</p>
<h2>Resolve CCD Contacts</h2>
<p>This job will take the collision results from the previous job and update position and velocity of the involved bodies. If an object hits another object, its time will be 'stolen' (it will move less far than it should according to its velocity).</p>
<h2>Finalize Contact Cache, Contact Removed Callbacks</h2>
<p>This job will:</p>
<ul>
<li>Swap the read/write contact cache and prepare the contact cache for the next step.</li>
<li>It will detect all contacts that existed previous step and do not exist anymore to fire callbacks for them through the <a class="el" href="class_j_p_h_1_1_contact_listener.html">ContactListener</a> interface.</li>
</ul>
<h2>Solve Position Constraints, Update Bodies Broad Phase</h2>
<p>A number of these jobs will run in parallel. Each job takes the next unprocessed island and run the position based constraint solver. This fixes numerical drift that may have caused constrained bodies to separate (remember that the constraints are solved in the velocity domain, so errors get introduced when doing a linear integration step). It will run until either the applied position corrections are too small or until the max amount of iterations is reached (<a class="el" href="struct_j_p_h_1_1_physics_settings.html#ab9c83a563942948352e7c091e7656e62">PhysicsSettings::mNumPositionSteps</a>).</p>
<p>It will also notify the broad phase of the new body positions / AABBs.</p>
<p>When objects move too little the body will be put to sleep. This is detected by taking the biggest two axis of the local space bounding box of the shape together with the center of mass of the shape (all points in world space) and keep track of 3 bounding spheres for those points over time. If the bounding spheres become too big, the bounding spheres are reset and the timer restarted. When the timer reaches a certain time, the object has is considered non-moving and is put to sleep. <br  />
</p>
<h2>Apply Gravity, Setup/Solve Velocity Constraints</h2>
<p>In the second and later integration sub steps, we combine the Apply Gravity, Setup Velocity Constraints and the Solve Velocity Constraints jobs. There are multiple of these jobs and they each process simulation islands until there are no more. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
